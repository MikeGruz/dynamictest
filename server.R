# to use: connect to Shiny Server with base url + '/?method=[method],[method],[method]' etc

shinyServer(function(input, output, session) {

  # set up reactive container for method list
  methodList <- reactiveValues()

  # pull testing parameters
  observe({
    query <- parseQueryString(session$clientData$url_search)
    if (!is.null(query[['method']])) {

      # parse uri for methods
      methodList$methods <- strsplit(unlist(query), split=",")

      # source the methods
      sapply(
        sapply(methodList$methods, function(x){
          paste("tests/", paste(x, '.R', sep=''), sep='')
        }), source
      )

    }
  })

  genProblem <- function() {
    # sample from URI methods
    problem <- do.call(sample(unlist(methodList$methods), 1), args=list())

    return(problem)
  }

  # container for reactive problem set
  prob <- reactiveValues()

  # reset problem space on "next problem" click
  observeEvent(input$nextProb, {

    # get problem set
    prob$problem <- genProblem()

    # output problem to UI
    output$problemText <-  renderUI(p(prob$problem$text))
    output$problem <-  renderUI(p(prob$problem$problemDisp))
    output$answer <-  renderUI(
      switch(prob$problem$input,
             "numeric" = numericInput("answer", "Answer", value=""),
             "text" = textInput("answer", "Answer", value=""),
             "multichoice" = radioButtons("answer", "Answer",
                                          choices = prob$problem$choices,
                                          selected = character(0))
      )
    )

    # remove correct/incorrect text
    output$check <- renderUI({
      p(" ")
    })

  }, ignoreNULL = TRUE)

  # when submit clicked, check answer
  observeEvent(input$submit, {

    # isolate solution from reactive
    solution <- isolate(prob$problem$solution)

    output$check <- renderUI({
      if (input$answer == solution) {
        h3(style="color:green;", "Correct")
      } else {
        p(style="color:red;", "Incorrect")
      }
    })

  })


})










